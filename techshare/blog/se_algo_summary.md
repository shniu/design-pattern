
## Algorithmic Summary

### todo 资源

- [大数问题](https://blog.csdn.net/walxiaosage/article/details/48251761)
- 编程珠玑
- 剑指offer
- [2018/2019/校招/春招/秋招/算法/机器学习(Machine Learning)/深度学习(Deep Learning)/自然语言处理(NLP)/C/C++/Python/面试笔记](https://github.com/imhuay/Algorithm_Interview_Notes-Chinese/tree/master/C-%E7%AE%97%E6%B3%95)
- [leetcode](https://leetcode.com/discuss/interview-question/operating-system)
- https://github.com/xuelangZF/LeetCode

### 如何高效的学习数据结构和算法

- 理解什么是数据结构和算法

现在先不急于下结论，等把所有相关的知识都学完后，思考之后再给出答案。这里留个 todo

- 学习的重点

1. 先学会复杂度分析
2. 学习最常用最基础的数据结构和算法
3. 学习每个数据结构和算法的时候，要学习它的“来历”，“自身的特点”，“适合解决的问题”，“实际的应用场景”
4. 辩证的思考，多问为什么，训练自己的思维

- 学习的技巧，可以事半功倍

1. 边学边练，适度刷题
2. 多问，多思考，多互动
3. 打怪升级学习法

- 知识需要一点点沉淀，功夫要用在平时

学习知识的过程是反复迭代、不断沉淀的过程。

### 复杂度分析

- 为什么要复杂度分析

对于一个算法来讲，总得需要一种方式来评估它的效率如何。我们可以对一段程序采取运行的方式来统计执行结果，从而得出效率。但是这种方式存在如下两个比较大的问题：

1. 测试结果依赖测试环境
2. 测试结果依赖数据规模

所以，很难得到普适性。复杂度分析就是为了解决诸如此类的问题，我们需要一个不用具体的测试数据来测试，不需要具体的测试环境，就可以粗略地估计算法的执行效率的方法。

- 复杂度的表示法

算法的执行效率，粗略来说，可以理解为代码的执行时间，空间用得少，时间用的少的算法，就是更加好的算法。一般情况下，我们使用大 O 来表示复杂度。大 O 表示法的核心意思是代码执行时间随数据规模增长的变化趋势，也就是渐近时间复杂度。对复杂度分析可以掌握如下的要点：

1. 只关注循环执行次数最多的一段代码。大 O 分析法关注的是变化趋势，常量、低阶、系数会被忽略掉
2. 总复杂度等于量级最大的那段代码的复杂度
3. 嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

- 复杂度量级

1. 常量阶 O(1)
2. 对数阶 O(logn)
3. 线性阶 O(n)
4. 线性对数阶 O(nlogn)
5. 平方阶 O(n^2) k次方阶 O(n^k)
6. 指数阶 O(2^n)
7. 阶乘阶 O(n!)

- 空间复杂度

表示算法的存储空间与数据规模之间的增长关系，和时间复杂度的类似。

```
渐进时间，空间复杂度分析为我们提供了一个很好的理论分析的方向，并且它是宿主平台无关的，能够让我们对我们的程序或算法有一个大致的认识，让我们知道，比如在最坏的情况下程序的执行效率如何，同时也为我们交流提供了一个不错的桥梁，我们可以说，算法1的时间复杂度是O(n)，算法2的时间复杂度是O(logN)，这样我们立刻就对不同的算法有了一个“效率”上的感性认识。

当然，渐进式时间，空间复杂度分析只是一个理论模型，只能提供给粗略的估计分析，我们不能直接断定就觉得O(logN)的算法一定优于O(n), 针对不同的宿主环境，不同的数据集，不同的数据量的大小，在实际应用上面可能真正的性能会不同，个人觉得，针对不同的实际情况，进而进行一定的性能基准测试是很有必要的，比如在统一一批手机上(同样的硬件，系统等等)进行横向基准测试，进而选择适合特定应用场景下的最有算法。

综上所述，渐进式时间，空间复杂度分析与性能基准测试并不冲突，而是相辅相成的，但是一个低阶的时间复杂度程序有极大的可能性会优于一个高阶的时间复杂度程序，所以在实际编程中，时刻关心理论时间，空间度模型是有助于产出效率高的程序的，同时，因为渐进式时间，空间复杂度分析只是提供一个粗略的分析模型，因此也不会浪费太多时间，重点在于在编程时，要具有这种复杂度分析的思维。

```

- 最好、最坏情况时间复杂度

- 平均时间复杂度

- 均摊分析

### 基础数据结构 - 数组

数组（Array）是一个最基本的数据结构，使用频率很高，主要可以用以下几个点来解释什么是数组：

- 线性表。数组是一种线性表结构，线性表中的数据像是排成一条线一样，只有前后之分。
- 连续的内存空间。数组在内存上的表现是被分配为连续的内存空间。数组在存储数据时要保证数据的连续性。
- 存储相同数据类型的数据。

数组的特性：

- 支持数据随机访问。在访问数组时，使用的寻址方式是直接寻址，通过数组首地址计算出指定位置的数组元素的内存地址。
- 随机访问的时间复杂度是 O(1), 便于随机访问
- 数组插入和删除操作是低效的，因为涉及大量元素的迁移。在数组尾部插入复杂度为 O(1), 但是在 K 的位置插入 O(n)
- 对于无序数组的插入，是可以将复杂度降低到 O(1) 的，直接将第 k 个位置的数据复制到数组尾部，将新数据复制给位置 k
- 删除操作的复杂度和插入一样。如果数组不要求有序，可以节省很多资源，具体做法是，标记删除的元素，等到数组大小不够用时在执行删除动作，做数据的搬移
- 数组要警惕越界检查

**容器和数组的对比：**

容器是对数组的封装，并支持动态扩容。比如 Java 中的 ArrayList, C++ 中的 Vector.

开发应用和开发基础框架对数组和容器的选择是不一样的，框架追求极致的性能体验，优先考虑使用数组。

**数组为什么要从下标0开始，而不是1**

- 减少了一次减法操作指令，会提高一点效率

```
// 下标是 0 的计算过程
a[k]_addr = base_addr + k * type_size

// 下标是 1 的计算过程
a[k]_addr = base_addr + (k-1) * type_size
```

- 历史原因，C 语言的涉及者将数组从 0 开始编号，其他语言为了易于接受，沿用了；但也有一些特殊的语言


### Sort Algorithmic

// todo

// 对所有的排序算法做个全方位的总结，形成自己的算法基础认知
