
这是 2019 年第 34 周 (2019.08.18~2019.08.24)

第 1 次打卡

### Algorithm

由于最近在研究 MySQL，Innodb 存储引擎的索引是用的 B+ Tree，所以本周算法部分有必要做些树算法相关的练习。

- [#94 二叉树的中序遍历 (Binary Tree Inorder Traversal)](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

二叉树中序遍历，给定一个二叉树，返回它的中序遍历；中序遍历是：
> 对于一个树，遍历的方式分为深度优先遍历和广度优先遍历，深度优先遍历又分为前序，中序，后序；其中中序遍历的方式就是遍历左子树->根节点->右子树

根据中序遍历的特定，首先能想到的就是使用递归实现，代码：

```
/**
 * 使用递归实现的二叉树中序遍历
 */
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList();
        inorderRecursive(root, result);
        return result;
    }
    /**
     * 递归实现
     */
    private void inorderRecursive(TreeNode node, List<Integer> result) {
        // 节点为null，表明已经到头了
        if (node != null) {
            // 先递归遍历左子树，直到最左的节点
            if (node.left != null) {
                inorderRecursive(node.left, result);
            }
            
            // 递归退出时，把节点的值加入到结果列表中
            result.add(node.val);
            
            // 递归遍历右子树
            if (node.right != null) {
                inorderRecursive(node.right, result);
            }
        }
        
    }
}
```
递归实现的代码很简洁，但是需要在脑中演化整个过程，这是难点。递归是基于方法压栈实现，每个方法在调用时都有自己的本地方法栈，当满足了某个退出条件时，就一个一个的出栈，接着执行后面的代码。

复杂度分析：
1. 时间复杂度 O(n)
2. 空间复杂度, 和树的形状有关，最坏情况下是 O(n), 平均是 O(logn); 最坏情况是树高为n，会压栈n次

有一种说法是，凡是能用递归实现的都可以使用非递归的方式实现，那思路就是使用循环+栈的方式，代码如下：

```
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) { 
        List<Integer> result = new ArrayList<>();
        Stack<TreeNode> stack = new Stack<>();
        TreeNode active = root;
        while (active != null || !stack.isEmpty()) {
            // 一直到找到最左边的节点，把这个路径上的所有节点都压栈
            while(active != null) {
                stack.push(active);
                // 活动节点换成左节点
                active = active.left;
            }
            
            // 找到了最左节点，就出来干活
            active = stack.pop();
            result.add(active.val);
            // 左子树和根节点访问了，就换到右子树；如果右子树也是null，就从栈中取了
            active = active.right;
        }
    }
}
```
循环+栈的实现就是模拟了递归中压栈出栈的规则，使用循环的方式实现，难点在于使用代码模拟整个过程。

复杂度分析：
1. 空间复杂度是 O(n)
2. 时间复杂度是 O(n)

类似的题目有：
1. [二叉树前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)
2. [二叉树后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

- [#105 从前序与中序遍历序列构造二叉树 (Construct binary tree from preorder and inorder traversal)](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

- [#106 从中序与后序遍历序列构造二叉树 (Construct binary tree from inorder and postorder traversal)](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

此外，还做了一些简单的题目
- [两数之和](https://leetcode-cn.com/problems/two-sum/)
主要解题思路有两个，一个是暴力循环；一个是借助 hash 表的快速查找降低时间复杂度;其中关键的转化在于根据当前值x，找到 target - x 即可完成。

```
class Solution {
    public int[] twoSum(int[] nums, int target) {
        return loopSolution(nums, target);
    }

    private int[] loopSolution(int[] nums, int target) {
        for (int i = 0; i < nums.length; i++) {
            for (int j = i + 1; j < nums.length; j++) {
                if (nums[j] == target - nums[i]) {
                    return new int[] {i, j};
                }
            }
        }
        return new int[] {};
    }
    
    private int[] hashSolution(int[] nums, int target) {
        // 指定长度的好处是对于 hash 表一次性申请足够的空间，省去扩容带来的时间消耗
        Map<Integer, Integer> map = new HashMap<>(nums.length);
        
        for (int i = 0; i < nums.length; i++) {
            int delta = target - nums[i];
            if (map.containsKey(delta) {
                return new int[] {map.get(delta), i};
            }
            
            map.put(nums[i], i);
        }
        
        return new int[] {};
    }
}
```

### Review

本周仔细阅读的第一篇英文文章是 [Scalable Web Architecture and Distributed Systems](http://www.aosabook.org/en/distsys.html),主要讲可扩展的web架构和分布式系统，属于入门级文章。

##### 分布式系统设计原则

首先总结了 Web 分布式系统设计的原则：
1. 可用性：可用性非常关键，是业务有损的，当服务不可用时会造成很大的经济损失；并且还会直接影响公司的形象和产品的推广。所以设计一个持续可用和弹性容错的系统非常重要，是基本的业务需要和技术需求。设计可用系统的关键点有：**仔细考虑关键组件的冗余、部分系统故障时快速恢复和问题发生后的优雅降级。**
2. 性能：这个关乎用户体验，需要做到快速响应和低延迟。
3. 可靠性：可靠性更多关心的是正确性，当多次访问同一个资源时，响应都是一致的；当修改了某个资源后，以后的请求都是修改后的状态；上传的数据、文件不能丢失找不到了，对于用户来讲，系统是一个可靠的保证，不管做了何种变更，以后都能安全正确的看到。
4. 可扩展性：扩展性更多的是来解决分布式系统中容量的问题的，当请求的负载增加了，可以应对；可以通过一些系统参数来体现：可以处理多少额外的流量、添加更多的存储容量是否容易、可以处理多少更多的事务。
5. 可维护性：设计系统时要考虑易于操作和使用。可维护性需要考虑的事项是在出现问题时易于诊断和排查问题，易于更新或修改，以及系统操作的简单性。
6. 成本：成本是另一个重要的因素。包括软硬件成本，部署维护成本，系统构建所需的开发人员时间，运行系统所需的操作工作量，所需的培训量。

以上是在设计分布式系统时需要考虑的诸多因素，所有这些因素综合考虑的结果，就慢慢演变为我们自己的系统架构，所以设计是需要权衡的。比如为了应对更多的流量，我们选择增加服务数量（扩展性），那么我们就需要应对更多服务和机器的管理工作（可维护性），以及增加服务带来的成本投入（硬件、人力、时间等）

##### 分布式系统的基础因素

当面对分布式系统设计时，我们需要应对：对于系统讲什么是正确的模块划分、怎样将划分后的模块优雅的组合在一起、什么才是正确的权衡。这篇文章会集中在几个核心因素上：服务、冗余、分片和异常处理。

使用图像托管应用举例来说明这些，基本需求是：
1. 应用



### Tip

写 mysql 索引相关的技术

### Share

todo
