
### 2018 第 39 周 （1008 ～ 1014）

#### 架构演进 - 高可用高性能高可扩展

- [设计高可用系统前，先考虑好如何定义系统的边界](https://mp.weixin.qq.com/s/_FkBJLKSDjwC_gwlHbTOJQ)

**总结：** 在一个采用了微服务架构的系统里，一个功能可能需要调用多个服务，因此每个部件的可用性决定了整个系统的可用性。这是弹性工程背后的核心逻辑。弹性工程意味着在设计时要把失效作为常规的考虑因素。

回压是一种弹性模式，回压就是对资源强加限制。比如队列长度限制、带宽限制、流量控制、消息速度限制、消息大小限制等等。如果我们不对资源加限制就是做了隐式限制，这样反而更危险，是在拿系统的可用性做赌注。

不管是队列、消息大小、查询或者流量，不对它们进行限制是一种弹性工程反模式。不对它们进行显式地限制，故障会以不可预期和非期望的方式发生。要记住，限制其实是时刻存在的，只是有时候它们被隐藏起来了。通过显式的限制，可以让故障的发生更加地可预期，而且发生故障的平均时间变长，而从故障中恢复的时间变短，只要在事先多做一些稍微复杂一点的工作。

**感悟：** 在系统设计时，要考虑如何更好的定义系统边界，从细微末节中去考量是否有哪些因素会对可用性造成威胁。这是一项工程问题。


- [弹性工程 - 构建弹性系统](http://www.itdks.com/course/796)

// todo

#### 分布式技术

- [分布式系统理论基础](https://mp.weixin.qq.com/s/p4PEZPjxJyYXKpkCCdShbw)

https://mp.weixin.qq.com/s?src=3&timestamp=1539159444&ver=1&signature=vx*N7EvfFqpmUOjwGF9wUIcxy31qP2i1s0ow3-ZGdLFNmUIWHULD4pWHmpUUd5rJpv2xqqhL1Ku7k1SAX6gCQBYy8OBEwm2HUegXM*lGiKtHxmnfbskGvJu4WDm7sf4y9d7v9zqKCxw-pV7NpHlJ08*2XUmQuivOUsgiVGJQKQ0=  系统架构设计理论与原则、负载均衡及高可用系统设计速记  架构之家

// todo

- [分布式数据](https://vonng.gitbooks.io/ddia-cn/content/part-ii.html)

// todo

#### Devops

- [Docker 背后的内核知识 -- Namespace 资源隔离 - 上](http://dwz.cn/4W0izO)
- [Docker 背后的内核知识 -- Namespace 资源隔离 - 下](http://dwz.cn/4WLWEb)

// todo

#### 服务化&微服务&虚拟化

- [Microservices - Martin Fowler](https://martinfowler.com/articles/microservices.html) & [中译版](https://blog.csdn.net/wurenhai/article/details/37659335)

**总结：** 这篇文章是微服务的入门级的，Martin 大师写的

microservices 是软件架构领域中众多新名词中的一个，在过去的时间里，有很多团队在应用这种架构模式，但是并没有统一的标准来描述微服务和我们如何去做。

微服务开发应用的方式是一组分别运行在不同进程中的服务套件，服务之间通过轻量级的消息通信，这些服务构建在业务能力范围之内并且使用独立的自动化部署机制。

和单体服务相比，单体服务所有的程序模块都运行在一个进程内，部署和更新程序需要更新整个应用，扩展需要扩展整个服务，但是随着应用变的复杂后，单体服务的部署就会出现让人挫败的事情，更新某一块功能都会重新构建和部署整个服务，而且即使模块化做的比较好，改动一个地方也会影响到其他地方的变动，不能部分变动或部分部署。微服务的好处就凸显出来了，微服务是有服务套件构成的，每一个服务都运行在独立的进程中，都独立与其他服务，可以按需扩容或减容，并且允许每个服务使用不同的语言和不同的技术栈，可以同时被不同的团队管理。

微服务架构特特点：

1. 通过服务组件化. a component is a unit of software that is independently replaceable and upgradeable. 微服务使用服务作为基本组件，因为服务可被独立部署，库却不可以
2. 围绕业务能力组织
3. 当做产品而不是项目
4. 智能终端和弱化通道
5. 分散治理
6. 分散化的数据管理。当对概念模式下决心进行分散管理时，微服务也决定着分散数据管理。微服务架构强调服务间事务的协调，并清楚的认识一致性只能是最终一致性以及通过补偿运算处理问题。
7. 基础设施自动化
8. 容错设计。使用服务作为组件的一个结果在于应用需要有能容忍服务的故障的设计。由于服务可以随时故障，快速故障检测，乃至，自动恢复变更非常重要。对微服务来说，监控是至关重要的，它能快速发现这种紧急不良行为，让我们迅速修复它。微服务团队期望清楚的监控和记录每个服务的配置，比如使用仪表盘显示上/下线状态、各种运维和业务相关的指标。对断路器（circuit breaker）状态、目前的吞吐量和时延细节。
9. 渐进式设计。当你试图软件系统拆分成组件时，你将面临着如何拆分的问题。组件可以被独立替换和更新的，这意味着我们寻找的关键在于，我们要想象着重写一个组件而不影响它们之前的协作关系。使用微服务，你只需要发布你要修改的服务就可以了。

微服务是未来吗？微服务是一个值得企业认真思考的东西。
1. 在组件化方面的任何努力，其成功都依赖于软件如何拆分成适合的组件。指出组件化的准确边界应该在那，这是非常困难的。改良设计要承认边界的权益困境和因此带来的易于重构的重要性。但是当你的组件是被远程通信的服务时，重构比进程内的库又要困难的多。服务边界上的代码迁移是困难的，任务接口的变更需要参与者的共同协作，向后兼容的层次需要被增加，测试也变更更加复杂。
2. 如果组件并没有清晰的划分，你的工作的复杂性将从组件内部转向组件间的关系。做这事不仅要围绕着复杂，它也要面对着不清晰和更难控制的地方。很容易想到，当你在一个小的、简单的组件内找东西，总比在没有关系的混乱的服务间要容易。
3. 团队技能也是重要的因素。无论什么样的架构模式，都需要有与之匹配的团队技能。

#### 设计思想与编程范式

-  [函数式编程](https://mp.weixin.qq.com/s/T4MuHWgB3Ydq9mXco962ng)

**总结：** 函数式编程（Functional Programming）可以做更为抽象的范型（[范型编程](https://en.wikipedia.org/wiki/Generic_programming),[2](https://blog.csdn.net/pongba/article/details/2544894)）。

纯函数：传进来的数据不改，改完的东西复制一份拷出去，然后没有状态。函数式技术：first class function（头等函数），tail recursion optimization（尾递归优化），map & reduce ，pipeline（管道），recursing（递归），currying（柯里化），higher order function（高阶函数）等。

pipeline（管道）借鉴于 Unix Shell 的管道操作——把若干个命令串起来，前面命令的输出成为后面命令的输入，如此完成一个流式计算。（注：管道绝对是一个伟大的发明，它的设计哲学就是 KISS – 让每个功能就做一件事，并把这件事做到极致，软件或程序的拼装会变得更为简单和直观。这个设计理念影响非常深远，包括今天的 Web Service、云计算，以及大数据的流式计算等。）

函数式编程是个非常古老的概念，它的核心思想是将运算过程尽量写成一系列嵌套的函数调用，关注的是做什么而不是怎么做，因而被称为声明式编程。以 Stateless（无状态）和 Immutable（不可变）为主要特点，代码简洁，易于理解，能便于进行并行执行，易于做代码重构，函数执行没有顺序上的问题，支持惰性求值，具有函数的确定性——无论在什么场景下都会得到同样的结果。

- [傻瓜函数式编程](https://github.com/justinyhuang/Functional-Programming-For-The-Rest-of-Us-Cn/blob/master/FunctionalProgrammingForTheRestOfUs.cn.md)

**总结：** 写的很不错，从函数式编程的历史讲起，从lambda数学演算过渡到函数式编程，值得去思考，可以多度几遍。

- [如何掌握程序语言](http://yinwang0.lofter.com/post/183ec2_47bea8)
- [什么是语义学](http://yinwang0.lofter.com/post/183ec2_47bec0)
- [怎样写一个解释器](http://yinwang0.lofter.com/post/183ec2_47bfb7)

**总结：** 看完以上三遍文章，发现了一个优秀程序员和普通程序员的差距，从自己过往6年的工作中，很多对计算机的理解，对计算机本质的理解，对解决实际问题的理解都是很浅层次的，我认知的世界和现实世界的巨大落差。一直以来，我都享受着现成工具带来的便捷和理所当然，并尽一切努力去收集各种理所当然便捷的工具，却很少停下来去思考，那些工具之所以成为人人都使用的工具的本质。在自己的固有局限之下，来自工作中的各种快快快上线的压力下妥协了，初心忘了，更多的时候是一味用拿来主义的工具去将产品的功能堆砌成可运行的系统，以便能够交付任务，因此而体会不到编程带来的一丝快感，体会不到作为工程师天生的创造力和创新力。我理解到的所谓本质，就是要去直面事物本来的面貌，而不是在它的周围打转，一直去苦恼它到底是个啥，感觉像个傻子；比如说编程语言，有各式各样的（Java/C/Lisp/Golang等），让我们疲于应付；如果每种语言我们都去学，真的是有心无力，及时这样还是有心往之；和文中作者所说是一样的，我对于学习编程语言有一种“落人之后”的恐惧，极力的去想学习时下各种时髦的语言，总觉着学习到的越多越好，一直以来就是不分昼夜不分青红皂白的埋头苦学，我觉着这是我的困境和局限之一；对我自身而言，学过的编程语言也有4种以上了，但是没有一门是精通的；问题也许不出在语言是否难学，可能在于我对程序语言本身的认知有问题，或者说根本不清楚程序语言的本质是什么，也不曾去深入思考过，所有语言在一定层次抽象下其实是有共性的，从语言的层面出发一点点往深里去探索，是可以追溯到计算机整个体系的，计算机的本质，什么理论支撑了计算机科学；然而程序语言的本质是什么呢，我现在的理解还很浅薄，而我要做的就是每当遇到一个问题和困境时，要直击本质和核心，这样才是最高效的。

#### 前端生态

- [浏览器的工作原理：新式网络浏览器幕后揭秘](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/)

// doing 5% 很棒的文章

**总结：** 这是一篇很长的文章，可能需要几次才能读完了。

浏览器的高层结构：

1. 用户界面
2. 浏览器引擎
3. 渲染引擎
4. 网络
5. 用户界面后端
6. Javascript 解释器
7. 数据存储

从渲染引擎说起

![渲染引擎的主流程](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/flow.png)

渲染引擎（呈现引擎）一般过程是解析HTML文档，将标记转换成“内容树”上的 DOM 节点，CSS 也会被解析，并结合之前的 DOM 树构建出一颗呈现树，呈现树包含了很多带有视觉属性的矩形，它们的排列顺序决定了在屏幕上的顺序；呈现树构建完成之后，就会进入到布局阶段，为每个节点分配一个坐标，然后进入绘制阶段，在屏幕上实际绘制呈现，绘制是由UI后端进行支持的。这是一个渐进的过程，不必等到整个 HTML 文档解析完毕之后，就会开始构建呈现树和设置布局。

#### 技术管理和工程师文化

- [技术漫谈：为何KPI毁了索尼，而OKR却成就了谷歌？](https://mp.weixin.qq.com/s/QBmbTu40psN0eaRyIa9MmQ)

**总结：** 很多公司都会推行 KPI 来做业绩考核，而 KPI 存在如此之久也是有其真正的用武之地，但是 KPI 在发挥作用的同时也在慢慢的毁掉一个公司很多有创造力的方面。对一个技术团队来讲，实行 KPI 更是困难的事情，技术人需要自由和创造，一味的追求 KPI 会抹杀掉创新和主动性；此外如何量化技术人员本身是一件很头大的事情，bug数？代码行数？绩效指标是什么？等等问题。作者面临着大多数人都面临的问题，开始尝试 OKR ...

对于使用 OKR 来开展工作，最大的难点就是需要深入理解 OKR，OKR 与 KPI 又有什么样的区别？OKR 的关键在于 Objectievs，KPI 的关键在于 Indicators，这两者的不同是整个思维方式的不同，关注点的不同，方向的不同。OKR 更关注目标，我们需要完成和为之奋斗的目标，更加明确和有效；KPI 的更关注量化指标，这个指标是人根据环境拍出来的，所有人为了这个量化指标努力，可以不择手段；然而指标并不代表目标，指标有可能是错的，但目标一定是对的，“并不是有了工作才有目标，而是相反，有了目标才能确定每个人的工作。所以企业的使命和任务，必须转化为目标”

OKR 和 KPI 又是有联系的，KR 的分解需要 KPI 的量化支持，所以 OKR 是要需要可衡量的，KPI 的可量化就是其中一种，还可以是里程碑的方式
OKR 要不要和绩效考核绑定
OKR 的目标需要自上而下分解和自下而上提炼，所以中间的leader至关重要，要对目标做提炼和转化，要深入理解 OKR 的内涵。

OKR 对于个人而言也是一种非常好的工具。


**感悟：** 对一个技术团队来讲，实行 KPI 更是困难的事情，这个问题也是我的公司之前遇到的一个大问题，也极力去引导实行 OKR 的工作方式，而这带来的挑战确实很大，需要有一个共识的过程，不能让团队成员产生错误的理解，慢慢纠正，不断获取反馈来改进落地执行的效果。

#### 大千世界 百家之言

- [资中筠：不要和不思考的人争论](https://mp.weixin.qq.com/s/f_7_8Qidu_X5IyJ1l2JSKA)

我观察过很多“争论”的场景，也经常被卷入争论的漩涡。发现这个现象有其“规律性”：中国式争论，其实都不是真正的争论，多数都是因为话语的对等，陷入抬杠的尴尬境地。

争论问题，首先是争论的双方要有一个前提：彼此都是思考者。只有这样，才能就共同的话题展开讨论。

争论还需要共同的逻辑修养，跟一个不懂逻辑的人争论，几句话就必然张冠李戴了。

有些人的头脑，已经形成了思维定势，定势之源正是几十年的洗脑。这样的人，只能由着他去。争论是很难动摇他的定势的，除非巨大的变革。
