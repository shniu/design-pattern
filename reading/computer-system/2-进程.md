
其实本来不太想再去总结关于进程的东西了，慢慢发现自己对与他的理解还是很不到位的，遂更加想深深的理解一下

从一下几个方面进行强化理解：

- 进程模型，以及他在计算机历史中发展的过程
- 为什么我们需要进程
- Linux 中的进程模型的实现
- 进程下的线程模型
- 进程和线程在并发编程中所处的角色和能力
- Linux 下并发编程的系统调用
- 各种编程语言对并发编程的支持，如 Java C++ Golang Nodejs Python等

### 从 OS 说起

我们为什么需要 OS 就不再去追根溯源了，简单来说不可能让每个程序员在编写应用的时候都从硬件开始写起吧，让他们自行来管理各种计算机资源，并且完成这些工作对于大多数人来讲并不轻松，会耗费大量的人力物力，所以就都交给 OS 来做吧，让 OS 面向硬件，提供友好的应用编程接口给我们使用，让 OS 来帮我们管理各种计算机资源，提供友好的编程接口给我们使用。所以伟大的 Unix 操作系统、Linux 操作系统就诞生了...

- 抽象。

抽象是管理复杂性的一个关键，OS 的一个主要任务就是创建好的抽象，并实现和管理它所创建的抽象，供应用程序使用。如文件就是OS中一个非常好的抽象。

- 资源管理者

OS 的主要任务就是记录哪个程序程序在使用什么资源，对资源请求进行分配，评估使用代价，并且为不同的程序和用户调解互相冲突的资源请求。资源的多路复用有两种方式：空间复用和时间复用。因为 CPU 是计算机里最主要的竞争资源，在时间上的复用主要是 CPU 的时钟分片方式，每个程序顺序使用 CPU 来执行任务。在空间上的复用，比如内存分块，每个程序分配获得一块内存，而不是一个程序独占所有内存；磁盘也是这类资源。

随着计算机系统的发展，出现了 OS 的概念，因为最初的计算机是没有 OS 的，那个时候将运行指令存储到穿孔卡片、磁盘机上，在使用的时候人为的启动计算机读入这些指令进行计算；考虑到效率实在太低，并且各种技术也在进步，在多道程序设计、分时系统之上，慢慢演化出现代操作系统，其中进程是 OS 中一个很关键的组成部分；对于任务的处理，以前是一个一个顺序来做的，好了之后就进入下一个，但是这种方式资源利率低（因为可能在执行一个任务的时候会出现 IO，IO 是非常慢的操作，CPU 就空转，很浪费）、不具备公平性（只能有一个任务独占资源，其他任务等着）、不够人性化等，所以 OS 就做了一个抽象，将每类任务当作一个个的进程去执行和调度，这样就可以在某个进程（任务）做如 IO 这种费时的操作的时候就让出 CPU 资源，调度其他的进程来用；另外一个好处是 OS 的 CPU 分片也可以很好的进行调度不同进程。

### 进程模型

上面简单说了点进程的起源。进程是在 OS 中的一个抽象表示，它代表了一组资源和一个正在执行的程序，是以独立的个体存在的，在 OS 中会有很多个这种“独立个体”，分别承担了 OS 的不同职责，如网络服务进程、图形化窗口进程等等；他们共同构成了和谐的计算机运行状态。

在任务执行过程中，必定会需要很多资源，如CPU、内存、寄存器、打开的文件、IO等。进程模型是由[多道程序设计](https://baike.baidu.com/item/多道程序设计/10804195)进化而来的, 所以简称模型可以简单的描述如下：

```
1. 进程代表一组资源和在这些资源上运行的程序实体，包括程序计数器、内存、寄存器、文件句柄等
2. 进程在 OS 中被组织为一个顺序的流程
3. 每个进程内部有自己的控制流程，每个进程有自己的虚拟 CPU，虚拟地址等，所谓虚拟就是进程自己感觉是独占了整机资源
4. 在一个确定的时刻，只有一个进程在实际执行，不同进程之间是轮流使用 CPU 的，一般在 20 ～ 30 ms 做一次重新调度
5. 进程被定义为一个活动，由程序、输入、输出和状态等构成的动态实体，存在于系统中
6. 进程间的切换调度是由进程的调度算法来完成的，系统根据算法来决定调用哪个就绪的进程来执行
```
总体概括一下，进程生命周期：

- 进程创建，分配资源
- 进程间切换，进程在不同状态间转换
- 进程使命完成，结束运行，回收资源

