
其实本来不太想再去总结关于进程的东西了，慢慢发现自己对与他的理解还是很不到位的，遂更加想深深的理解一下

从一下几个方面进行强化理解：

- 进程模型，以及他在计算机历史中发展的过程
- 为什么我们需要进程
- Linux 中的进程模型的实现
- 进程下的线程模型
- 进程和线程在并发编程中所处的角色和能力
- Linux 下并发编程的系统调用
- 各种编程语言对并发编程的支持，如 Java C++ Golang Nodejs Python等

### 从 OS 说起

我们为什么需要 OS 就不再去追根溯源了，简单来说不可能让每个程序员在编写应用的时候都从硬件开始写起吧，让他们自行来管理各种计算机资源，并且完成这些工作对于大多数人来讲并不轻松，会耗费大量的人力物力，所以就都交给 OS 来做吧，让 OS 面向硬件，提供友好的应用编程接口给我们使用，让 OS 来帮我们管理各种计算机资源，提供友好的编程接口给我们使用。所以伟大的 Unix 操作系统、Linux 操作系统就诞生了...

- 抽象。

抽象是管理复杂性的一个关键，OS 的一个主要任务就是创建好的抽象，并实现和管理它所创建的抽象，供应用程序使用。如文件就是OS中一个非常好的抽象。

- 资源管理者

OS 的主要任务就是记录哪个程序程序在使用什么资源，对资源请求进行分配，评估使用代价，并且为不同的程序和用户调解互相冲突的资源请求。资源的多路复用有两种方式：空间复用和时间复用。因为 CPU 是计算机里最主要的竞争资源，在时间上的复用主要是 CPU 的时钟分片方式，每个程序顺序使用 CPU 来执行任务。在空间上的复用，比如内存分块，每个程序分配获得一块内存，而不是一个程序独占所有内存；磁盘也是这类资源。

随着计算机系统的发展，出现了 OS 的概念，因为最初的计算机是没有 OS 的，那个时候将运行指令存储到穿孔卡片、磁盘机上，在使用的时候人为的启动计算机读入这些指令进行计算；考虑到效率实在太低，并且各种技术也在进步，在多道程序设计、分时系统之上，慢慢演化出现代操作系统，其中进程是 OS 中一个很关键的组成部分；对于任务的处理，以前是一个一个顺序来做的，好了之后就进入下一个，但是这种方式资源利率低（因为可能在执行一个任务的时候会出现 IO，IO 是非常慢的操作，CPU 就空转，很浪费）、不具备公平性（只能有一个任务独占资源，其他任务等着）、不够人性化等，所以 OS 就做了一个抽象，将每类任务当作一个个的进程去执行和调度，这样就可以在某个进程（任务）做如 IO 这种费时的操作的时候就让出 CPU 资源，调度其他的进程来用；另外一个好处是 OS 的 CPU 分片也可以很好的进行调度不同进程。

### 进程模型

上面简单说了点进程的起源。进程是在 OS 中的一个抽象表示，它代表了一组资源和一个正在执行的程序，是以独立的个体存在的，在 OS 中会有很多个这种“独立个体”，分别承担了 OS 的不同职责，如网络服务进程、图形化窗口进程等等；他们
