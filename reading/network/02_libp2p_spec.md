
> 本篇文章为 libp2p specs 的中文翻译，以此来了解更多关于 libp2p 的详细内容。
> libp2p 项目地址：https://github.com/libp2p/specs

---

## 1. 介绍

在开发 IPFS 星际文件系统时，我们发现必须在具有不同网络设置和功能的异构设备上运行分布式文件系统所带来的几个挑战。在这个过程当中，我们不得不重新审视整个网络栈并制定解决方案，以克服多个层和协议的设计决策所带来的障碍，而不会破坏兼容性或重新创建技术。

为了构建这个库，我们专注于独立解决问题，使用强大的抽象创建不太复杂的解决方案，这些抽象在组合时可以为对等应用程序提供成功工作的环境。

### 1.1 动机

`libp2p` 是我们构建分布式系统集体经验的产物，因为将责任推给了开发者，让他们决定希望应用程序如何与网络中的其他人进行互操作，并且有利于配置和可扩展性，而不是对网络设置做出假设。

实质上，使用 `libp2p` 的节点应该能够和使用各种不同的传输协议的节点进行通信，包括连接中继，并且可以根据需要协商不同的协议。

### 1.2 目标

`libp2p` 规范和实现的目标是：

- 满足各种协议的使用：
  - 传输协议：TCP, UDP, SCTP, UDT, uTP, QUIC, SSH 等
  - 需要认证的传输协议：TLS, DTLS, CurveCP, SSH
  
- 有效利用套接字 (连接复用)
- 使对等体之间的通信能够通过一个套接字进行多路复用 (避免握手开销)
- 使用协商过程启用在多个对等体之间使用的多协议和相应版本
- 向后兼容
- 在当前系统中工作
- 使用当前网络的全部能力
- Have NAT traversal
- 启用连接中继
- 启用加密通道
- 有效利用底层传输（例如本机流复用，本机身份验证等）

## 2. 网络栈技术现状分析

本节向读者介绍网络堆栈的可用协议和体系结构的分析。 目标是提供推断结论的基础，并理解为什么 `libp2p` 具有它所具有的要求和架构。

### 2.1 C/S 模型

客户端 - 服务器模型表示信道两端的双方具有不同的角色，它们支持不同的服务和/或具有不同的能力，或者换句话说，它们拥有不同的协议。

构建客户端 - 服务器应用程序一直是出于以下原因的自然趋势：

- 数据中心内的带宽远远高于客户端可以相互连接的带宽
- 由于有效使用和大量库存，数据中心资源相当便宜
- 它使开发人员和系统管理员可以更轻松地对应用程序进行细粒度控制
- 它减少了要处理的异构系统的数量（尽管数量仍然很大）
- 像 NAT 这样的系统使得客户端很难找到并相互通信，迫使开发人员to perform very clever hacks来绕过这些障碍
- 开始设计协议时假设开发人员将从一开始就创建客户端 - 服务器应用程序

我们甚至学会了如何隐藏互联网上网关后面的分布式系统的所有复杂性，使用旨在执行点对点操作的协议，如 HTTP, 使得应用看到和理解每个请求产生的级联服务调用是不透明的。

`libp2p` 提供了从 C/S 监听向拨号监听交互的转变，其中不隐含哪些实体，拨号器或侦听器具有哪些功能或者能够执行哪些操作。今天在两个应用程序之间建立连接是一个需要解决的多层问题，这些连接不应该有目的偏差，而应该支持其他几个协议在已建立的连接之上工作。在客户端 - 服务器模型中，在没有来自客户端的先前请求的情况下发送数据的服务器被称为推送模型，这通常会增加更多的复杂性; 相比之下，在拨号器 - 侦听器模型中，两个实体都可以独立地执行请求。

### 2.2 按解决方案对网络堆栈协议进行分类

在深入研究 `libp2p` 协议之前，了解已广泛使用和部署的大量协议有助于维护当今简单的抽象。 例如，当人们考虑 HTTP 连接时，人们可能会天真地认为 HTTP / TCP / IP 是所涉及的主要协议，但实际上有更多协议参与，具体取决于使用情况，所涉及的网络等等。 DNS，DHCP，ARP，OSPF，Ethernet，802.11（Wi-Fi）等许多协议都涉及到。 展望互联网服务提供商自己的网络将会发现更多。

此外，值得注意的是传统的 7 层 OSI 模型表征不适合 `libp2p`。 相反，我们根据协议的角色对协议进行分类，即他们解决的问题。 OSI 模型的上层面向应用程序之间的点对点链接，而 libp2p 协议在各种不同的安全模型下更多地针对具有各种属性的各种大小的网络。 不同的 libp2p 协议可以具有相同的角色（在OSI模型中，这将是“寻址同一层”），这意味着多个协议可以同时运行，所有解决一个角色（而不是传统OSI中的每层协议）堆积）。 例如，引导列表，mDNS，DHT 发现和 PEX 都是角色“节点发现”的形式; 它们可以共存甚至协同作用。

#### 2.2.1 建立物理连接

- Ethernet
- Wi-Fi
- Bluetooth
- USB

#### 2.2.2 定位机器和进程

- IPv4
- IPv6
- Hidden addressing, like SDP

#### 2.2.3 发现节点或服务

- ARP
- DHCP
- DNS
- Onion

#### 2.2.4 通过网络路由消息

- RIP(1, 2)
- OSPF
- BGP
- PPP
- Tor
- I2P
- cjdns

#### 2.2.5 传输协议

- TCP
- UDP
- UDT
- QUIC
- WebRTC data channel

#### 2.2.6 应用程序相互通信的语义

- RMI
- Remoting
- RPC
- HTTP

### 2.3 目前的缺点

虽然我们目前有一整套可用于我们服务的协议进行通信，但丰富多样的解决方案会产生自己的问题。 目前，应用程序很难通过多种传输来支持和使用（例如，浏览器应用程序中缺少TCP / UDP堆栈）。

也没有“存在链接”，这意味着对等体没有在几个传输中宣布自己的概念，因此其他对等体可以保证它始终是同一个对等体。

## 3. 要求和考虑因素

### 3.1 传输协议不可知论

`libp2p` 是 transport-agnostic(套接字通信层关于其底层传输机制是不可知的), 所以可以在任何的传输协议之上运行。它甚至不依赖于 IP；它也可以运行在 NDN，XIA 和其他新的互联网架构之上。

为了推出可能的传输，`libp2p` 使用了 [multiaddr](https://github.com/multiformats/multiaddr), 一种自描述的地址形式。这使得 `libp2p` 在系统的任何地方不透明地处理地址是可能的，并且在网络层支持各种传输协议。在 `libp2p` 实际的地址形式是 `ipfs-addr`, 一个以 IPFS 节点ID 结尾的 multiaddr。下面就是一些合法的 `ipfs-addr`:

```
# IPFS over TCP over IPv6 (typical TCP)
/ip6/fe80::8823:6dff:fee7:f172/tcp/4001/ipfs/QmYJyUMAcXEw1b5bFfbBbzYu5wyyjLMRHXGUkCXpag74Fu

# IPFS over uTP over UDP over IPv4 (UDP-shimmed transport)
/ip4/162.246.145.218/udp/4001/utp/ipfs/QmYJyUMAcXEw1b5bFfbBbzYu5wyyjLMRHXGUkCXpag74Fu

# IPFS over IPv6 (unreliable)
/ip6/fe80::8823:6dff:fee7:f172/ipfs/QmYJyUMAcXEw1b5bFfbBbzYu5wyyjLMRHXGUkCXpag74Fu

# IPFS over TCP over IPv4 over TCP over IPv4 (proxy)
/ip4/162.246.145.218/tcp/7650/ip4/192.168.0.1/tcp/4001/ipfs/QmYJyUMAcXEw1b5bFfbBbzYu5wyyjLMRHXGUkCXpag74Fu

# IPFS over Ethernet (no IP)
/ether/ac:fd:ec:0b:7c:fe/ipfs/QmYJyUMAcXEw1b5bFfbBbzYu5wyyjLMRHXGUkCXpag74Fu
```

注意：此时，不存在不可靠的实现。 尚未定义用于定义和使用不可靠传输的协议接口。 有关不可靠与可靠运输的更多信息，请参见[此处](http://www.inetdaemon.com/tutorials/basic_concepts/communication/reliable_vs_unreliable.shtml)。 在WebRTC的上下文中，CTRL + F“可靠”在[这里](https://www.html5rocks.com/en/tutorials/webrtc/basics/#signaling)。

### 3.2 多重复用

`libp2p` 协议是多个协议的集合。为了节省资源并使连接更容易，libp2p 可以通过单个端口（例如TCP或UDP端口）执行其所有操作，具体取决于所使用的传输。libp2p 可以通过点对点连接复用其众多协议。 这种多路复用适用于可靠流和不可靠的数据报。

libp2p 是务实的。 它试图在尽可能多的设置中使用，模块化和灵活，以适应各种用例，并尽可能少的选择。 因此libp2p网络层提供了我们称之为“多重复用”的东西：

- 可以复用多个监听网络接口
- 可以复用多个传输协议
- 可以复用每个对等体的多个连接
- 可以复用多个客户端协议
- 每个连接可以复用多个流，每个连接（SPDY，HTTP2，QUIC，SSH）
- 有流量控制（背压，公平）
- 使用不同的临时密钥加密每个连接

给个 IPFS 节点的列子：

- 侦听特定的TCP / IP地址
- 侦听不同的TCP / IP地址
- 侦听SCTP / UDP / IP地址
- 侦听UDT / UDP / IP地址
- 有多个连接到另一个节点X.
- 有多个连接到另一个节点Y.
- 每个连接打开多个流
- 多路复用HTTP2到节点X的流
- 通过SSH将节点流复制到节点Y.
- 安装在libp2p之上的一个协议使用每个对等体一个流
- 安装在libp2p之上的一个协议使用每个对等体的多个流

不提供这种级别的灵活性使得无法在各种平台，用例或网络设置中使用libp2p。 所有实现都支持所有选择并不重要; 重要的是规范足够灵活，允许实现精确地使用他们需要的东西。 这可确保复杂的用户或应用程序约束不会排除libp2p作为选项。

// todo

## 4. 架构

`libp2p` 的设计遵循了 Unix 的哲学，创建易于理解和测试的小组件。为了适应不同的技术和场景，并且随着时间的发展可更新，这些组件应该是可替换的。

不同的节点根据它们自身的能力可以支持不同的协议，任何节点都可以扮演拨号者和监听者，连接一旦建立就可以在两者之间重用，消除客户和服务之间的差距。

`libp2p` 接口充当多个子系统的薄贴面，这些子系统是节点间能够进行通信所必需的。只要它们遵循标准化接口，就允许这些子系统构建在其他子系统之上。这些子系统适合的主要区域是：

- 节点路由 - 决定使用哪些节点路由特定消息的机制。路由可以递归地，迭代地或甚至在广播/多播模式中完成。
- Swarm - 处理所有触及 libp2p '打开流'部分的内容，包括协议复用，流复用，NAT 遍历和连接中继，同时是多传输。
- 分布式记录存储 - 用于存储和分发记录的系统。 记录是其他系统用于发送信号，建立链接，通知对等体或内容等的小条目。 它们在更广泛的互联网中与 DNS 具有类似的作用
- 发现 - 查找或识别网络中的其他节点


这些子系统中的每一个都公开了一个众所周知的接口（参见第6章的接口），并且可以相互使用以实现其目标。 该系统的全局概述是：

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                                  libp2p                                         │
└─────────────────────────────────────────────────────────────────────────────────┘
┌─────────────────┐┌─────────────────┐┌──────────────────────────┐┌───────────────┐
│   Peer Routing  ││      Swarm      ││ Distributed Record Store ││  Discovery    │
└─────────────────┘└─────────────────┘└──────────────────────────┘└───────────────┘
```

